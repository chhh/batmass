<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BatMass</title>
    <link>http://www.batmass.org/</link>
    <description>Recent content on BatMass</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Apr 2016 00:59:00 -0400</lastBuildDate>
    <atom:link href="http://www.batmass.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>License</title>
      <link>http://www.batmass.org/license/</link>
      <pubDate>Thu, 14 Apr 2016 00:59:00 -0400</pubDate>
      
      <guid>http://www.batmass.org/license/</guid>
      <description>&lt;p&gt;Copyright [2016] [Dmitry Avtonomov]&lt;/p&gt;

&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &amp;ldquo;License&amp;rdquo;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.apache.org/licenses/LICENSE-2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &amp;ldquo;AS IS&amp;rdquo; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Developing the first plugin</title>
      <link>http://www.batmass.org/tutorial/developing-first-plugin/</link>
      <pubDate>Thu, 14 Apr 2016 00:33:00 -0400</pubDate>
      
      <guid>http://www.batmass.org/tutorial/developing-first-plugin/</guid>
      <description>

&lt;p&gt;In this guide we will develop a new module for BatMass that will add support for a new file format for detected LC/MS features.&lt;br /&gt;
We will need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#create-a-new-netbeans-module&#34;&gt;Create a new NetBeans module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#create-a-parser-for-the-file&#34;&gt;Create a parser for the file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-support-for-the-new-file-type&#34;&gt;Add support for the new file type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-capabilities-to-the-node&#34;&gt;Add support for importing the file into a project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#making-our-data-recognizable-by-table-and-map2d-viewers&#34;&gt;Add basic support for viewing the data in tabular viewer and overlay of data over Map2D&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The prerequisite for this tutorial is that you have the development environment set up. If you don&amp;rsquo;t have that yet, make sure to go through &lt;a href=&#34;http://www.batmass.org/tutorial/setting-up-development-environment/&#34;&gt;the setting up dev environment tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This tutorial might be a little too much if you had no exposure to the NetBeans platform development, so I also strongly recommend that you visit &lt;a href=&#34;https://netbeans.org/features/platform/all-docs.html&#34;&gt;the NetBeans platform documentation website&lt;/a&gt; and at least walk through &lt;a href=&#34;https://platform.netbeans.org/tutorials/nbm-quick-start.html&#34;&gt;NetBeans Platform Quick Start tutorial&lt;/a&gt; it provides plus read &lt;a href=&#34;http://wiki.netbeans.org/NbmIdioms#NetBeans_APIs_in_a_Nutshell&#34;&gt;this document&lt;/a&gt;. The documentation website has a lot of tutorials covering many aspects of the platform in great detail.&lt;/p&gt;

&lt;p&gt;Also recommended are: &lt;a href=&#34;https://platform.netbeans.org/tutorials/nbm-runtime-container.html&#34;&gt;NetBeans Platform Runtime Container Tutorial&lt;/a&gt; - so you&amp;rsquo;ll know the anatomy of a platform application better and the set of 10 videos links to which can be found &lt;a href=&#34;https://platform.netbeans.org/tutorials/nbm-10-top-apis.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;create-a-new-netbeans-module&#34;&gt;Create a new NetBeans module&lt;/h2&gt;

&lt;p&gt;Open &lt;code&gt;BatMass&lt;/code&gt; module suite in NetBeans, expand its node in Project Explorer, right click the &lt;code&gt;Modules&lt;/code&gt; node, click &lt;code&gt;Add New&lt;/code&gt;. Follow the instructions in the wizard to create a new module. Give it a descriptive, unique name and &lt;em&gt;Code Name Base&lt;/em&gt;, the code name base will be used as the base package of all the source files. All &lt;em&gt;BatMass&lt;/em&gt; modules use &lt;code&gt;umich.ms.batmass&lt;/code&gt; as the base-name and add suffixes for different modules, e.g. &lt;code&gt;umich.ms.batmass.filesupport&lt;/code&gt; for the &lt;em&gt;File Support&lt;/em&gt; module. This is needed to avoid class-name clashes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/add-new-module-01.png&#34; alt=&#34;Add new module&#34; /&gt;
&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/add-new-module-02.png&#34; alt=&#34;Give the module a name&#34; /&gt;
&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/add-new-module-03.png&#34; alt=&#34;Provide code name base&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Add 3 packages &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;providers&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;model&lt;/code&gt; package will contain our java model for the data in the file.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;data&lt;/code&gt; package will contain the wrappers which will adapt the raw data model to the format suitable for viewers.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;providers&lt;/code&gt; package will hold the necessary infrastructure to hook into the project system - it will give a way to import existing files into the project, provide an icon for the node, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;create-a-parser-for-the-file&#34;&gt;Create a parser for the file&lt;/h2&gt;

&lt;p&gt;We will use DIA-Umpire Signal Extraction text output file as an example. It&amp;rsquo;s a simple delimited text format with the first line being column headers, the rest being data stored as text. Even though these are simple text delimited files, we will not be using a library for parsing, instead we&amp;rsquo;ll provide a fast home-grown reader. We&amp;rsquo;ll be using existing helper classes from other &lt;em&gt;BatMass&lt;/em&gt; modules for that.&lt;/p&gt;

&lt;p&gt;To use functionality provided by some NetBeans module from another module two requirements must be met:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The module providing the functionality should declare the package it wants to expose to the outside world as public API&lt;/li&gt;
&lt;li&gt;The module that needs to use that functionality must declare a dependency on the providing module. For code completion to work as expected, first compile the provider module.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;providing-public-api-from-modules&#34;&gt;Providing public API from modules&lt;/h3&gt;

&lt;p&gt;Expand &lt;code&gt;BatMass -&amp;gt; Modules&lt;/code&gt; node in the project explorer, open &lt;code&gt;FileSupport Core (BatMass)&lt;/code&gt; module by double clicking on it. In &lt;em&gt;Source Packages&lt;/em&gt; node navigate to &lt;code&gt;umich.ms.batmass.filesupport.core.util&lt;/code&gt; package. We will be using the &lt;code&gt;DelimitedFiles&lt;/code&gt; class. This package is already declared public, but for the learning purposes let&amp;rsquo;s go ahead and check that. Right click &lt;code&gt;FileSupport Core (BatMass)&lt;/code&gt; module in the Project Explorer and go to &lt;code&gt;Properties -&amp;gt; API Versioning&lt;/code&gt;. You should see that checkboxes of all packages but one are already selected, these packages will be available to other modules if they set dependency on the &lt;code&gt;FileSupport Core (BatMass)&lt;/code&gt; module. If you change selection here, recompile the module by right clicking the module node, and running &lt;em&gt;Build&lt;/em&gt; (&lt;em&gt;Clean Build&lt;/em&gt; is not necessary).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/expose-public-api-from-module.png&#34; alt=&#34;Expose public API from module&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;setting-another-module-as-a-dependency&#34;&gt;Setting another module as a dependency&lt;/h3&gt;

&lt;p&gt;Now right click the newly created &lt;code&gt;DIA Umpire SE Features&lt;/code&gt; module, go to &lt;code&gt;Properties -&amp;gt; Libraries&lt;/code&gt;. In the &lt;code&gt;Module Dependencies&lt;/code&gt; tab click &lt;code&gt;Add Dependency&lt;/code&gt;. In the search bar at the top start typing &amp;ldquo;FileSupport&amp;rdquo;, it should find 2 modules: &amp;ldquo;FileSupport (BatMass)&amp;rdquo; and &amp;ldquo;FileSupport Core (BatMass)&amp;rdquo;. We&amp;rsquo;re interested in the second one, so select it and click OK, you should now see it in the dependencies list.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/search-for-module-dependency.png&#34; alt=&#34;Search for module dependency&#34; /&gt;
&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/module-dependency-added.png&#34; alt=&#34;Module dependency added&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We should now be able to use &lt;code&gt;umich.ms.batmass.filesupport.core.util.DelimitedFiles&lt;/code&gt; in our module.&lt;/p&gt;

&lt;p&gt;It might seem like a lot of work at first, but as you get used to it, it&amp;rsquo;s not harder than adding dependencies in maven, for example. It is also possible to create maven-based NetBeans modules, but we will not be covering that in this tutorial and this is not used in BatMass.&lt;/p&gt;

&lt;h3 id=&#34;model-the-data&#34;&gt;Model the data&lt;/h3&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;You can skip that part of this section if you like. It just describes the usual Java stuff of reading a file and parsing it into some POJO (Plain Old Java Object). This does not have to be done the way described here.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;You can find a sample Umpire Signal Extraction text output file in the folder &lt;em&gt;DiaUmpireSeSeFeatures/resources&lt;/em&gt; inside &lt;em&gt;BatMass&lt;/em&gt; project. We will not be using all the columns from the file, only a few. Here&amp;rsquo;s our model class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UmpireSeIsoCluster {
    protected double rtLo;
    protected double rtHi;
    protected int scanNumLo;
    protected int scanNumHi;
    protected int charge;
    protected double[] mz = new double[4];
    protected double peakHeight;
    protected double peakArea;

    /**
     * Bare minimum info required to plot something.
     * @param rtLo
     * @param rtHi
     * @param mz
     */
    public UmpireSeIsoCluster(double rtLo, double rtHi, double mz) {
        this.rtLo = rtLo;
        this.rtHi = rtHi;
        this.mz[0] = mz;
    }

    // ... getters and setters
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will have a factory class, that knows how to parse the file, I will omit the implementation of &lt;code&gt;create(Path)&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * A simple array-list storage for parsed LCMS features from Umpire PeakCluster csv files.
 * @author Dmitry Avtonomov
 */
public class UmpireSeIsoClusters {
    public static String COL_NAME_RT_LO = &amp;quot;StartRT&amp;quot;;
    public static String COL_NAME_RT_HI = &amp;quot;EndRT&amp;quot;;
    public static String COL_NAME_SCAN_NUM_LO = &amp;quot;StartScan&amp;quot;;
    public static String COL_NAME_SCAN_NUM_HI = &amp;quot;EndScan&amp;quot;;
    public static String COL_NAME_CHARGE = &amp;quot;Charge&amp;quot;;
    public static String COL_NAME_MZ1 = &amp;quot;mz1&amp;quot;;
    public static String COL_NAME_MZ2 = &amp;quot;mz2&amp;quot;;
    public static String COL_NAME_MZ3 = &amp;quot;mz3&amp;quot;;
    public static String COL_NAME_MZ4 = &amp;quot;mz4&amp;quot;;
    public static String COL_NAME_PEAK_HEIGHT = &amp;quot;PeakHeight1&amp;quot;;
    public static String COL_NAME_PEAK_AREA = &amp;quot;PeakArea1&amp;quot;;

    protected List&amp;lt;UmpireSeIsoCluster&amp;gt; clusters;

    public UmpireSeIsoClusters() {
        clusters = new ArrayList&amp;lt;&amp;gt;();
    }

    public List&amp;lt;UmpireSeIsoCluster&amp;gt; getClusters() {
        return clusters;
    }

    /**
     * Factory method to create UmpireSeIsoClusters object from a file.
     * @param path the file to parse data from
     * @return
     */
    public static UmpireSeIsoClusters create(Path path) throws IOException {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-support-for-the-new-file-type&#34;&gt;Adding support for the new file-type&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll be working in the &lt;code&gt;providers&lt;/code&gt; package.&lt;br /&gt;
You can find a working example of what we&amp;rsquo;re about to create in package &lt;code&gt;umich.ms.batmass.filesupport.files.types.agilent.cef.providers&lt;/code&gt; of &lt;code&gt;FileSupport (BatMass)&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;The first thing to do is to make the system recognize the new files.&lt;/p&gt;

&lt;h3 id=&#34;registering-a-typeresolver&#34;&gt;Registering a TypeResolver&lt;/h3&gt;

&lt;p&gt;To make the system recognize new files we need to register an implementation of &lt;code&gt;umich.ms.batmass.filesupport.core.spi.filetypes.FileTypeResolver&lt;/code&gt; interface using &lt;code&gt;@FileTypeResolverRegistration&lt;/code&gt; annotation. To simplify things there&amp;rsquo;s an abstract class &lt;code&gt;AbstractFileTypeResolver&lt;/code&gt;, so we&amp;rsquo;ll use that.&lt;/p&gt;

&lt;p&gt;Create a class &lt;code&gt;UmpireSeTypeResolver&lt;/code&gt; extending &lt;code&gt;AbstractFileTypeResolver&lt;/code&gt;. Then copy the contents of &lt;code&gt;AgilentCefTypeResolver&lt;/code&gt; for simplicity and modify as needed. After copy-pasting you&amp;rsquo;ll notice that some parts are underlined with a red wavy line (specifically &lt;code&gt;@StaticResource&lt;/code&gt;, &lt;code&gt;ImageUtilities&lt;/code&gt;). Those two come from other NetBeans modules provided by the NetBeans platform, so we&amp;rsquo;ll need to add dependencies. There is a simpler way, rather than going to the &lt;em&gt;Properties&lt;/em&gt; of your module. Place the cursor on the line with an error and press &lt;kbd&gt;Alt+Enter&lt;/kbd&gt; and select &lt;code&gt;Search module dependency for ...&lt;/code&gt;, in this case there will be a single search hit for both errors: &amp;ldquo;Utilities API&amp;rdquo; and &amp;ldquo;Common Annotations&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;@StaticResource&lt;/code&gt; annotation is particularly useful - it checks if a static resource can be found at the provided path. If you copy-pasted everything from &lt;code&gt;AgilentCefTypeResolver&lt;/code&gt;, then after adding the correct dependency the line&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@StaticResource
public static final String ICON_BASE_PATH = &amp;quot;umich/ms/batmass/filesupport/resources/features_16.png&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;should still be underlined with the error saying that it &amp;ldquo;cannot find resource&amp;rdquo;.&lt;br /&gt;
Create a new package &lt;code&gt;resources&lt;/code&gt; under &lt;code&gt;umich.ms.batmass.diaumpire&lt;/code&gt; and put some 16x16 pixels icon there. You can copy &lt;code&gt;features_16.png&lt;/code&gt; from &lt;code&gt;umich.ms.batmass.filesupport.resources&lt;/code&gt; (which is in &lt;code&gt;FileSupport (BatMass)&lt;/code&gt; module) and change the &lt;code&gt;ICON_BASE_PATH&lt;/code&gt; to the correct path to the new icon. Fix other things, like the FileFilter, which will be used in the FileChooser when the user imports the file in.&lt;/p&gt;

&lt;p&gt;I ended up with the following class, everything should be clear to you, except maybe &lt;code&gt;BMFileFilter&lt;/code&gt; and &lt;code&gt;@FileTypeResolverRegistration&lt;/code&gt;. I used &lt;code&gt;FileFilterUtils.suffixFileFilter(EXT, IOCase.INSENSITIVE)&lt;/code&gt; instead of an extension filter, because we want to match the files that end in &amp;ldquo;_PeakCluster.csv&amp;rdquo;. You&amp;rsquo;ll also need to add a dependencies on &amp;ldquo;Lib Apache Commons IO&amp;rdquo; to make this work. We&amp;rsquo;ll get to that &lt;code&gt;@FileTypeResolverRegistration&lt;/code&gt; thing right after the code listing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FileTypeResolverRegistration(
        fileCategory = UmpireSeTypeResolver.CATEGORY,
        fileType = UmpireSeTypeResolver.TYPE
)
public class UmpireSeTypeResolver extends AbstractFileTypeResolver {
    private static final UmpireSeTypeResolver INSTANCE = new UmpireSeTypeResolver();

    @StaticResource
    public static final String ICON_BASE_PATH = &amp;quot;umich/ms/batmass/diaumpire/resources/features_16.png&amp;quot;;
    public static final ImageIcon ICON = ImageUtilities.loadImageIcon(ICON_BASE_PATH, false);

    public static final String CATEGORY = &amp;quot;features&amp;quot;;
    public static final String TYPE = &amp;quot;umpire-se&amp;quot;;
    protected static final String EXT = &amp;quot;_PeakCluster.csv&amp;quot;;
    protected static final BMFileFilter FILE_FILTER = new UmpireSeSeFileFilter();
    protected static final String DESCRIPTION = &amp;quot;DIA-Umpire Signal Extraction peak clusters&amp;quot;;

    public static UmpireSeTypeResolver getInstance() {
        return INSTANCE;
    }

    @Override
    public String getCategory() {
        return CATEGORY;
    }

    @Override
    public String getType() {
        return TYPE;
    }

    @Override
    public ImageIcon getIcon() {
        return ICON;
    }

    @Override
    public String getIconPath() {
        return ICON_BASE_PATH;
    }

    @Override
    public boolean isFileOnly() {
        return true;
    }

    @Override
    public BMFileFilter getFileFilter() {
        return FILE_FILTER;
    }

    public static class UmpireSeSeFileFilter extends BMFileFilter {

        public UmpireSeSeFileFilter() {
            super(FileFilterUtils.suffixFileFilter(EXT, IOCase.INSENSITIVE));
        }

        @Override
        public String getShortDescription() {
            return EXT;
        }

        @Override
        public String getDescription() {
            return DESCRIPTION;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filetyperesolverregistration&#34;&gt;@FileTypeResolverRegistration&lt;/h3&gt;

&lt;p&gt;Now as promised we move on to &lt;code&gt;@FileTypeResolverRegistration&lt;/code&gt;. This annotation is defined in &lt;code&gt;FileSupport Core (BatMass)&lt;/code&gt; module. What it does is it registers an instance of &lt;code&gt;FileTypeResolver&lt;/code&gt; in the &amp;lsquo;layer&amp;rsquo; file. If you&amp;rsquo;ve read/watched basic info about the NetBeans platform linked to in the beginning of this page, you should know that a platform application has a kind of an XML file in it which stores most configuration information. You can edit this file manually, however it is much less error prone to automate the process, and that is done with annotations and annotation processors. After you&amp;rsquo;ve annotate a class and try to build the module, the annotation processors are run first - they scan the source code for annotations that they (the processors) support and perform whatever actions are coded in them. With &lt;code&gt;@FileTypeResolverRegistration&lt;/code&gt; annotation the &lt;code&gt;FileTypeResolverRegistrationProcessor&lt;/code&gt; will read it and automagically create an entry in the &amp;lsquo;layer&amp;rsquo;. Also, there is not just a single layer file, each module can have its own layer and layers from all the modules comprising an application are merged before application starts.&lt;br /&gt;
The good news is that the NetBeans IDE provides a GUI to check the contents of the layer. In the Project Explorer open &lt;code&gt;FileSupport (BatMass)&lt;/code&gt; module, and expand the &lt;em&gt;Important Files&lt;/em&gt; node in it, you will see the &amp;lsquo;XML Layer&amp;rsquo; node in there. If you expand it, there are two entries:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lt;this layer&amp;gt; - this one contains the layer entries that this particular module has in its layer file&lt;/li&gt;
&lt;li&gt;&amp;lt;this layer in context&amp;gt; - this one shows the aggregated layer file for the whole application and the modifications/additions by the current module&amp;rsquo;s layer are shown in &lt;strong&gt;bold&lt;/strong&gt; font.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/locate-xml-layer-file.png&#34; alt=&#34;Locate XML Layer file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you now take a look at &lt;em&gt;Important Files&lt;/em&gt; for the module we&amp;rsquo;re creating, you won&amp;rsquo;t find the &amp;lsquo;XML Layer&amp;rsquo; entry there. Even though the annotation processor did its job, the entry only appears there after you create the &amp;ldquo;manual&amp;rdquo; version of the file, thankfully, adding the file is very easy: right click the module node in the Project Explorer, select &lt;code&gt;New -&amp;gt; Other -&amp;gt; Module Development -&amp;gt; XML Layer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/create-layer-xml-file.png&#34; alt=&#34;Create XML Layer file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You should now have the &lt;em&gt;layer.xml&lt;/em&gt; file in the root of your source packages and also the &amp;lsquo;XML Layer&amp;rsquo; node should have appeared under &amp;lsquo;Important Files&amp;rsquo;. If you&amp;rsquo;ve built the module, you&amp;rsquo;ll also see the instance of &lt;code&gt;UmpireSeTypeResolver&lt;/code&gt; has been registered under &lt;code&gt;BatMass/FileTypeResolvers/features/umpire-se&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/developing-first-plugin/layer-file-created.png&#34; alt=&#34;XML Layer file created&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;setting-up-the-node&#34;&gt;Setting up the Node&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re not done yet, this step only provided enough data to the system to be able to import the file in a project, we&amp;rsquo;ll also need to specify how the file should be rendered in the Project Explorer. For that we need to register an implementation of &lt;code&gt;FileNodeInfo&lt;/code&gt; interface in the layer. There&amp;rsquo;s an annotation for that as well, see &lt;code&gt;AgilentCefNodeInfo&lt;/code&gt; as an example.&lt;/p&gt;

&lt;p&gt;This one is much simpler, I&amp;rsquo;ll just copy-paste everything from the &lt;code&gt;AgilentCefNodeInfo&lt;/code&gt; class and change names as appropriate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NodeInfoRegistration(
        fileCategory = UmpireSeTypeResolver.CATEGORY,
        fileType = UmpireSeTypeResolver.TYPE
)
public class UmpireSeNodeInfo extends AbstractFileNodeInfo{

    @Override
    public FileTypeResolver getFileTypeResolver() {
        return UmpireSeTypeResolver.getInstance();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s not much going on here, we&amp;rsquo;ll be using the &lt;code&gt;AbstractFileNodeInfo&lt;/code&gt; class as base, which only leaves the implementation of &lt;code&gt;getFileTypeResolver()&lt;/code&gt; to us. We&amp;rsquo;ll simply return the singleton instance from our newly created type resolver, leaving the rest default.&lt;/p&gt;

&lt;h3 id=&#34;running-the-app-for-the-first-time&#34;&gt;Running the app for the first time&lt;/h3&gt;

&lt;p&gt;You can now try running the application! Right click &lt;em&gt;BatMass&lt;/em&gt; module suite in the Project Explorer and choose &lt;em&gt;Run&lt;/em&gt;. It will build the application first and then run it. If you get tons of errors, you have likely not built the dependent projects. If so, locate the other 3 yellow modules (&lt;em&gt;BatMassExt&lt;/em&gt;, &lt;em&gt;BatMassLibs&lt;/em&gt; and &lt;em&gt;MSFTBX&lt;/em&gt;) in the Project Explorer, right click and &lt;em&gt;Build&lt;/em&gt; each of them. When &lt;em&gt;BatMass&lt;/em&gt; starts, create a new Proteomics Project, right click &lt;em&gt;LC/MS Features&lt;/em&gt; node in it, choose &lt;em&gt;Import LC/MS Features&lt;/em&gt;. A file chooser should open and the File Types drop-down menu should contain an entry for the newly created data type.&lt;br /&gt;
In this example case I mande a type resolver which recognized the files by their file-name suffix, specifically looking for files which end in &amp;ldquo;_PeakCluster.csv&amp;rdquo;. If you create a file with that name anywhere in your filesystem and select it, it should be added as a child of &lt;em&gt;LC/MS Features&lt;/em&gt; node now.&lt;/p&gt;

&lt;p&gt;Even though the file has been imported into the project, not much can be done with it yet. We have neither exposed any system for parsing the file into meaningful data structures nor declared how the file can be viewed. However, if you right click the imported file, you&amp;rsquo;ll see that the &lt;em&gt;View&lt;/em&gt; sub-menu contains two actions: &lt;em&gt;Table&lt;/em&gt; and &lt;em&gt;Outline&lt;/em&gt;. How did that happen?&lt;/p&gt;

&lt;p&gt;Those two entries are &lt;em&gt;Actions&lt;/em&gt; and &lt;em&gt;Actions&lt;/em&gt; are registered for nodes in the project based on &lt;strong&gt;fileCategory&lt;/strong&gt; and &lt;strong&gt;fileType&lt;/strong&gt; which we used for the type resolver. They are registered using annotations as well. If you go back to &lt;code&gt;UmpireSeTypeResolver&lt;/code&gt; you&amp;rsquo;ll see that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Here&#39;s the registration annotation
@FileTypeResolverRegistration(
        fileCategory = UmpireSeTypeResolver.CATEGORY,
        fileType = UmpireSeTypeResolver.TYPE
)

// And here are the corresponding variables
public static final String CATEGORY = &amp;quot;features&amp;quot;;
public static final String TYPE = &amp;quot;umpire-se&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now you see that we have registered our new file-type under category &amp;ldquo;features&amp;rdquo; with type &amp;ldquo;umpire-se&amp;rdquo;. It so happens that some other module in &lt;em&gt;BatMass&lt;/em&gt; has already registered an two actions for the &amp;ldquo;features&amp;rdquo; category, that&amp;rsquo;s why we see those two available. If you read the last sentence carefully, you&amp;rsquo;ve probably noticed that I said the actions were registered for the &lt;strong&gt;category&lt;/strong&gt;, however with the type-system in &lt;em&gt;BatMass&lt;/em&gt; you can register actions for categories, for concrete file-types or even for categories only for certain types of projects. The targets of action registration only depend on the path in the layer where they&amp;rsquo;re registered.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll also notice that the &lt;em&gt;View&lt;/em&gt; actions are greyed-out, that&amp;rsquo;s because those actions expect the node to expose some resources, like file-parser or table-model-provider for tabular views. So far our node exposes nothing as we haven&amp;rsquo;t implemented any capabilities.&lt;/p&gt;

&lt;h2 id=&#34;adding-capabilities-to-the-node&#34;&gt;Adding capabilities to the node&lt;/h2&gt;

&lt;p&gt;So far our new node is pretty useless. We&amp;rsquo;ve seen those 2 actions appear, they are provided by a separate module &lt;code&gt;GUI (BatMass)&lt;/code&gt; which contains everything GUI related as its name suggests. Take a look at the &lt;code&gt;umich.ms.batmass.gui.nodes.actions&lt;/code&gt; package. Here live the actions that you can invoke from context menus of nodes in the Project Explorer. We&amp;rsquo;re interested in class &lt;code&gt;OpenFeature2DTable&lt;/code&gt; from &lt;code&gt;umich.ms.batmass.gui.nodes.actions.features&lt;/code&gt; package. It&amp;rsquo;s declared as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OpenFeature2DTable extends AbstractContextAwareAction&amp;lt;FeatureTableModelData&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this is a &lt;code&gt;ContextAwareAction&lt;/code&gt; which operates on &lt;code&gt;FeatureTableModelData&lt;/code&gt;. That means that it expects to find an instance of &lt;code&gt;FeatureTableModelData&lt;/code&gt; in the global Lookup (if you don&amp;rsquo;t know what a lookup is in the context of platform applications, read &lt;a href=&#34;https://dzone.com/articles/netbeans-lookups-explained&#34;&gt;this&lt;/a&gt;). When we select our node for the imported file so far it doesn&amp;rsquo;t expose this particular feature. &lt;em&gt;BatMass&lt;/em&gt; defines a single way to add things to a node&amp;rsquo;s lookup - via registering an implementation of &lt;code&gt;CapabilityProvider&lt;/code&gt; interface for a node using &lt;code&gt;@NodeCapabilityRegistration&lt;/code&gt; annotation. This interface has a single method &lt;code&gt;addCapabilitiesToLookup(InstanceContent, FileDescriptor)&lt;/code&gt; - when the method is invoked you are given the &lt;code&gt;InstanceContent&lt;/code&gt; that powers this node&amp;rsquo;s lookup (again, if you don&amp;rsquo;t know what I&amp;rsquo;m talking about, read &lt;a href=&#34;https://dzone.com/articles/netbeans-lookups-explained&#34;&gt;the link I&amp;rsquo;ve suggested above&lt;/a&gt;) and a &lt;code&gt;FileDescriptor&lt;/code&gt;, which is the &lt;em&gt;BatMass&lt;/em&gt; way of representing a link to a file in the filesystem.&lt;/p&gt;

&lt;p&gt;You can find an example to copy-paste from in &lt;code&gt;FileSupport (BatMass)&lt;/code&gt; module, package &lt;code&gt;umich.ms.batmass.filesupport.files.types.agilent.cef.providers&lt;/code&gt;, class &lt;code&gt;AgilentCefDataProvider&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So go ahead, create your own &lt;code&gt;UmpireSeDataProvider extends AbstractCapabilityProvider&lt;/code&gt;. &lt;code&gt;AbstractCapabilityProvider&lt;/code&gt; simplifies things for you by providing a default implementation of getting the UID. Press &lt;kbd&gt;Alt+Enter&lt;/kbd&gt; twice on the line declaring the class, the first time you&amp;rsquo;ll import the missing class, the second time you&amp;rsquo;ll choose &amp;ldquo;Implement all abstract methods&amp;rdquo;. When the method is created for you, &amp;ldquo;InstanceContent&amp;rdquo; will be underlined, that&amp;rsquo;s because it is defined in the &lt;em&gt;Lookup API&lt;/em&gt; module, which we did not include as a dependency yet. Go ahead, press &lt;kbd&gt;Alt+Enter&lt;/kbd&gt; once again and choose &amp;ldquo;Search module dependency for InstanceContent&amp;rdquo;.&lt;br /&gt;
Add the &lt;code&gt;@NodeCapabilityRegistration&lt;/code&gt; annotation to the class, using &amp;ldquo;fileCategory&amp;rdquo; and &amp;ldquo;fileType&amp;rdquo; from &lt;code&gt;UmpireSeTypeResolver&lt;/code&gt;. Code completion works in the annotations as well, so you can type &amp;ldquo;@NodeCapabilityRegistration()&amp;rdquo;, place the caret between the parentheses and press &lt;kbd&gt;Ctrl+Space&lt;/kbd&gt; to bring up a list of available properties for the annotation. We&amp;rsquo;ll only use &amp;ldquo;fileCategory&amp;rdquo; and &amp;ldquo;fileType&amp;rdquo; this time, mine so far looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NodeCapabilityRegistration(
        fileCategory = UmpireSeTypeResolver.CATEGORY,
        fileType = UmpireSeTypeResolver.TYPE)
public class UmpireSeDataProvider extends AbstractCapabilityProvider{

    @Override
    public void addCapabilitiesToLookup(InstanceContent ic, FileDescriptor desc) {

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we have nothing to add to the lookup yet. Things here get a little hairier because we don&amp;rsquo;t want to parse the file immediately as it has been imported, this should only be done when viewing data is requested and then several views might share the data and then it also needs to be unloaded from the memory when a viewer is closed, etc etc etc.&lt;/p&gt;

&lt;h2 id=&#34;making-our-data-recognizable-by-table-and-map2d-viewers&#34;&gt;Making our data recognizable by table and Map2D viewers&lt;/h2&gt;

&lt;p&gt;The Map2D still won&amp;rsquo;t know how to draw all those features, even though we&amp;rsquo;ve created a table model because it won&amp;rsquo;t know which columns are what. So we need another wrapper around &lt;code&gt;UmpireSeIsoCluster&lt;/code&gt; class that models just one line from the csv file that we&amp;rsquo;re parsing. It does know how to render instances of &lt;code&gt;ILCMSFeature2D&amp;lt;T&amp;gt;&lt;/code&gt; though. There&amp;rsquo;s a helper abstract class &lt;code&gt;AbstractLCMSFeature2D&amp;lt;T extends ILCMSTrace&amp;gt;&lt;/code&gt; which is a model of an isotopic cluster. It&amp;rsquo;s a simple container, which holds &lt;code&gt;ILCMSTrace&lt;/code&gt;s, each trace is just one m/z trace in time. There are no restrictions on implementations, you are free to provide arbitrary paths for traces, however this is a lot of work, so by default &lt;code&gt;AbstractLCMSFeature2D&lt;/code&gt; implements all m/z traces as simple bounding boxes (m/z, RT).&lt;/p&gt;

&lt;h3 id=&#34;wrapping-our-model-pojos&#34;&gt;Wrapping our model POJOs&lt;/h3&gt;

&lt;p&gt;So we&amp;rsquo;ll go ahead and create the following wrapper class in &lt;code&gt;umich.ms.batmass.diaumpire.data&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class UmpireSeFeature extends AbstractLCMSFeature2D&amp;lt;AbstractLCMSTrace&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As always, just copy-paste the contents from &lt;code&gt;AgilentCefFeature&lt;/code&gt; and modify as needed to fix all the errors and changing all instances of &lt;code&gt;AgilentCompound&lt;/code&gt; to &lt;code&gt;UmpireSeIsoCluster&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UmpireSeFeature extends AbstractLCMSFeature2D&amp;lt;AbstractLCMSTrace&amp;gt;{
    protected UmpireSeIsoCluster cluster;

    public UmpireSeFeature(AbstractLCMSTrace[] traces, int charge) {
        super(traces, charge);
    }

    public UmpireSeFeature(AbstractLCMSTrace[] traces) {
        super(traces);
    }

    public UmpireSeIsoCluster getCompund() {
        return cluster;
    }

    public void setCompund(UmpireSeIsoCluster cluster) {
        this.cluster = cluster;
    }

    public static UmpireSeFeature create(UmpireSeIsoCluster c) {
        int numTraces = c.getNumPeaks();

        AbstractLCMSTrace[] tr = new AbstractLCMSTrace[numTraces];
        for (int i = 0; i &amp;lt; numTraces; i++) {
            tr[i] = new AbstractLCMSTrace(c.getMz()[i], c.getRtLo(), c.getRtHi());
        }

        int z = c.getCharge();

        UmpireSeFeature acf = new UmpireSeFeature(tr, z);
        acf.setCompund(c);
        return acf;
    }

    @Override
    public Color getColor() {
        return cluster.getNumPeaks() &amp;gt; 1 ? Color.MAGENTA : Color.RED;
    }

    /**
     * Overriding this method, because we don&#39;t store shapes/bounds for LCMS Traces
     * in Umpire Features.
     * @return
     */
    @Override
    protected Rectangle2D.Double createBoundsFromTraces() {
        int traceNumLo, traceNumHi;
        traceNumLo = 0; // 0-th trace is required to be there
        traceNumHi = traces.length-1;

        double mzLo = traces[traceNumLo].getMz() - traces[traceNumLo].getMzSpread();
        double mzHi = traces[traceNumHi].getMz() + traces[traceNumHi].getMzSpread();
        double rtLo = Double.POSITIVE_INFINITY;
        double rtHi = Double.NEGATIVE_INFINITY;
        for (int i = 0; i &amp;lt; traces.length; i++) {
            AbstractLCMSTrace trace = traces[i];
            if (trace.getRtLo() &amp;lt; rtLo) {
                rtLo = trace.getRtLo();
            }
            if (trace.getRtHi() &amp;gt; rtHi) {
                rtHi = trace.getRtHi();
            }
        }

        return new Rectangle2D.Double(mzLo, rtHi, mzHi - mzLo, rtHi - rtLo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-the-table-model&#34;&gt;Creating the table model&lt;/h3&gt;

&lt;p&gt;We will now create the table model, as you would for any JTable. We&amp;rsquo;ll use &lt;code&gt;AbstractFeatureTableModel&lt;/code&gt; as the base class, as it provides an implementation of mechanisms for mapping the data from the table to a view on 2D map, however, it all depends on what data your viewer needs to display the data correctly. Add a dependency on &lt;code&gt;GUI Core (BatMass)&lt;/code&gt; module, you should be comfortable figuring out the way to do this yourself by now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UmpireSeTableModel extends AbstractFeatureTableModel {
    List&amp;lt;UmpireSeIsoCluster&amp;gt; features;

    protected String[] colNames = {
        /* 0 */ &amp;quot;Mono m/z&amp;quot;,
        /* 1 */ &amp;quot;Charge&amp;quot;,
        /* 2 */ &amp;quot;RT lo&amp;quot;,
        /* 3 */ &amp;quot;RT hi&amp;quot;,
        /* 4 */ &amp;quot;Scan lo&amp;quot;,
        /* 5 */ &amp;quot;Scan hi&amp;quot;,
        /* 6 */ &amp;quot;Total intensity&amp;quot;,
        /* 7 */ &amp;quot;Max intensity&amp;quot;,
    };
    protected Class[] colTypes = {
        /* 0 */ Double.class,
        /* 1 */ Integer.class,
        /* 2 */ Double.class,
        /* 3 */ Double.class,
        /* 4 */ Integer.class,
        /* 5 */ Integer.class,
        /* 6 */ Double.class,
        /* 7 */ Double.class,
    };

    public UmpireSeTableModel(List&amp;lt;UmpireSeIsoCluster&amp;gt; features) {
        this.features = features;
    }

    @Override
    public String getColumnName(int column) {
        return colNames[column];
    }

    @Override
    public int getRowCount() {
        return features.size();
    }

    @Override
    public int getColumnCount() {
        return colNames.length;
    }

    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        UmpireSeFeature f = features.get(rowIndex);
        UmpireSeIsoCluster c = f.getCluster();

        switch (columnIndex) {
            case 0:
                return c.getMz()[0];
            case 1:
                return c.getCharge();
            case 2:
                return c.getRtLo();
            case 3:
                return c.getRtHi();
            case 4:
                return c.getScanNumLo();
            case 5:
                return c.getScanNumHi();
            case 6:
                return c.getPeakArea();
            case 7:
                return c.getPeakHeight();
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we implement that &lt;code&gt;rowToRegion(int)&lt;/code&gt; method, then double-clicking the row will automatically bring us to the region that we calculate in that method in 2D map (if one is linked to the table viewer). Here&amp;rsquo;s a sample implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public MzRtRegion rowToRegion(int row) {
    if (row &amp;lt; 0 || row &amp;gt;= features.size())
        throw new IllegalStateException(String.format(&amp;quot;Conversion from illegal row index was requested, no such row index: [%s]&amp;quot;, row));
    UmpireSeFeature f = features.get(row);
    UmpireSeIsoCluster c = f.getCluster();
    if (f == null) {
        throw new IllegalStateException(String.format(&amp;quot;Should not happen, row index was ok, but the feature at this id was null.&amp;quot;));
    }

    // find the boundaries
    double mzLo = Double.POSITIVE_INFINITY;
    double mzHi = Double.NEGATIVE_INFINITY;
    double[] masses = c.getMz();
    for (int i = 0; i &amp;lt; c.getNumPeaks(); i++) {
        double m = masses[i];
        if (m &amp;lt; mzLo)
            mzLo = m;
        if (m &amp;gt; mzHi)
            mzHi = m;
    }
    double rtLo = c.getRtLo();
    double rtHi = c.getRtHi();

    // add half a dalton to the sides and 30 seconds each way in RT direction
    return new MzRtRegion(mzLo-0.5, mzHi+0.5, rtLo-0.5, rtHi+0.5);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enabling-automated-memory-handling&#34;&gt;Enabling automated memory handling&lt;/h3&gt;

&lt;p&gt;Ufff&amp;hellip; Everything will be wrapped into &lt;code&gt;FeatureData2D&lt;/code&gt; which is a &lt;code&gt;DataContainer&lt;/code&gt;&amp;hellip; This API is really over-engineered and only serves to provide a level of type safety. So just copy-paste everything from &lt;code&gt;AgilentCefTableModelData&lt;/code&gt; into a new class &lt;code&gt;UmpireSeFeatureTableModelData&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UmpireSeFeatureTableModelData extends FeatureTableModelData&amp;lt;UmpireSeFeature&amp;gt; {

    public UmpireSeFeatureTableModelData(DataSource&amp;lt;Features&amp;lt;UmpireSeFeature&amp;gt;&amp;gt; source) {
        super(source);
    }

    @Override
    public TableModel create() {
        Features&amp;lt;UmpireSeFeature&amp;gt; data = getData();
        if (data == null) {
            throw new IllegalStateException(&amp;quot;You must have loaded the data from the data source before calling create().&amp;quot;
                    + &amp;quot;Use .load(Object user) on this object first.&amp;quot;);
        }
        return new UmpireSeTableModel(data.getMs1().getList());
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;going-back-and-actually-putting-something-into-the-lookup-of-our-node&#34;&gt;Going back and actually putting something into the Lookup of our node&lt;/h3&gt;

&lt;p&gt;When we created &lt;code&gt;UmpireSeDataProvider&lt;/code&gt; we left &lt;code&gt;addCapabilitiesToLookup()&lt;/code&gt; method empty. Let&amp;rsquo;s fix this by copy-pasting code from &lt;code&gt;AgilentCefDataProvider&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NodeCapabilityRegistration(
        fileCategory = UmpireSeTypeResolver.CATEGORY,
        fileType = UmpireSeTypeResolver.TYPE)
public class UmpireSeDataProvider extends AbstractCapabilityProvider{

    @Override
    public void addCapabilitiesToLookup(InstanceContent ic, FileDescriptor desc) {
        URI uri = Utilities.toURI(desc.getPath().toFile());

        AgilentCefFeaturesDataSource source = new AgilentCefFeaturesDataSource(uri);
        AgilentCefTableModelData data = new AgilentCefTableModelData(source);
        ic.add(data);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, the last piece of the puzzle is missing - that &lt;code&gt;AgilentCefFeaturesDataSource&lt;/code&gt;, which we don&amp;rsquo;t have for our data yet. This is the last class that we&amp;rsquo;ll create - &lt;code&gt;UmpireSeFeaturesDataSource&lt;/code&gt; and as always, copy-paste the contents modifying it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UmpireSeFeaturesDataSource extends DefaultDataSource&amp;lt;Features&amp;lt;UmpireSeFeature&amp;gt;&amp;gt; {

    public UmpireSeFeaturesDataSource(URI origin) {
        super(origin);
    }

    @Override
    public Features&amp;lt;UmpireSeFeature&amp;gt; load() throws DataLoadingException {
        Features&amp;lt;UmpireSeFeature&amp;gt; features = new Features&amp;lt;&amp;gt;();
        try  {
            Path path = Paths.get(uri).toAbsolutePath();
            UmpireSeIsoClusters clusters = UmpireSeIsoClusters.create(path);
            if (clusters.getClusters().isEmpty())
                throw new DataLoadingException(&amp;quot;The size of the list of features after parsing Umpire file was zero.&amp;quot;);            
            for (UmpireSeIsoCluster c : clusters.getClusters()) {
                UmpireSeFeature feature = UmpireSeFeature.create(c);
                features.add(feature, 1, null);
            }
            return features;
        } catch (IOException ex) {
            throw new DataLoadingException(ex);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll get an error for that &lt;code&gt;features.add(feature, 1, null);&lt;/code&gt; because it uses a class defined in &lt;code&gt;MSFileToolbox Module&lt;/code&gt; module, add a dependency on that.&lt;/p&gt;

&lt;p&gt;Now we can fix the &lt;code&gt;UmpireSeDataProvider&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NodeCapabilityRegistration(
        fileCategory = UmpireSeTypeResolver.CATEGORY,
        fileType = UmpireSeTypeResolver.TYPE)
public class UmpireSeDataProvider extends AbstractCapabilityProvider{

    @Override
    public void addCapabilitiesToLookup(InstanceContent ic, FileDescriptor desc) {
        URI uri = Utilities.toURI(desc.getPath().toFile());

        UmpireSeFeaturesDataSource source = new UmpireSeFeaturesDataSource(uri);
        UmpireSeFeatureTableModelData data = new UmpireSeFeatureTableModelData(source);
        ic.add(data);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There should be no errors now, you should be able to right click the &lt;code&gt;DIA Umpire SE Features&lt;/code&gt; module that we were developing and click &lt;em&gt;Build&lt;/em&gt; then &lt;em&gt;Run&lt;/em&gt; the &lt;em&gt;BatMass&lt;/em&gt; module to test it out.&lt;/p&gt;

&lt;p&gt;Start the application, import some DIA-Umpire Singnal Extraction results into the &lt;code&gt;LC/MS Features&lt;/code&gt; node, import the corresponding mzXML file into &lt;code&gt;LC/MS Files&lt;/code&gt; node. With a right click on the &lt;code&gt;..._PeakCluster.csv&lt;/code&gt; file you should now have the option to open it in a table viewer and if you select &lt;strong&gt;BOTH&lt;/strong&gt; the mzXML file and the csv file, then right click any of those, there will be an option for overlay in Map2D.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using data access library</title>
      <link>http://www.batmass.org/tutorial/data-access-layer/</link>
      <pubDate>Thu, 14 Apr 2016 00:32:00 -0400</pubDate>
      
      <guid>http://www.batmass.org/tutorial/data-access-layer/</guid>
      <description>

&lt;p&gt;In this guide we will quickly go through using the standalone java library for accessing some common mass spectrometry data formats. This is the same library that powers &lt;em&gt;BatMass&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;All the classes responsible for parsing files live in &lt;code&gt;umich.ms.fileio.filetypes&lt;/code&gt; package, each in its own subpackage, e.g. &lt;code&gt;umich.ms.fileio.filetypes.pepxml&lt;/code&gt; for PepXML files. Most of those sub-packages contain a separate package &lt;code&gt;example&lt;/code&gt; with working examples.&lt;/p&gt;

&lt;p&gt;The source code for the library lives in &lt;a href=&#34;https://github.com/chhh/msftbx&#34;&gt;MSFTBX repository on GitHub&lt;/a&gt;. Start by cloning:&lt;br /&gt;
&lt;code&gt;git clone https://github.com/chhh/MSFTBX.git&lt;/code&gt;
and explore&lt;/p&gt;

&lt;h2 id=&#34;parsing-lc-ms-data-mzml-mzxml-files&#34;&gt;Parsing LC/MS data (mzML/mzXML files)&lt;/h2&gt;

&lt;p&gt;Unfortunately, it&amp;rsquo;s near impossible to easily access raw mass spec data from the original vendor file formats using java. You can convert most data from proprietary formats (&lt;em&gt;.RAW&lt;/em&gt; files for Thermo, &lt;em&gt;.d&lt;/em&gt; directories for Agilent, etc.) using &lt;code&gt;msconvert&lt;/code&gt; program from &lt;a href=&#34;http://proteowizard.sourceforge.net/&#34;&gt;ProteoWizard&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The API is separated into two parts. First you create a data source from your file. The data source can be used by itself, if you just want to iterate over spectra by yourself. It can also be attached to a special data structure, which handles data loading, management, indexing and garbage collection.&lt;/p&gt;

&lt;p&gt;mzML and mzXML share the same common base interface &lt;code&gt;umich.ms.fileio.filetypes.LCMSDataSource&lt;/code&gt;, you can use that if you want to write code that can work seamlessly with both file formats.
We will start by creating a data source and just reading spectra one by one, which is very ineffective.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws FileParsingException {

  // Creating data source
  Path path = Paths.get(&amp;quot;some-path-to.mzXML&amp;quot;);
  path = Paths.get(args[0]);
  MZXMLFile source = new MZXMLFile(path.toString());

  // Notice that we use fetchIndex() instead of getIndex().
  // fetchIndex() will either get a cached copy or parse it from
  // disk, if no cache is available. The index will be cached after parsing.
  MZXMLIndex index = source.fetchIndex();

  // The index gives you the scan numbers, on the lowest level you can parse
  // the file using those numbers. We need the raw scan numbers (the numbers
  // as they&#39;re used in the file). The internal scan numbering scheme always
  // renumbers all scans starting from 1 and increasing by 1 consecutively.

  for (Integer scanNumRaw : index.getMapByRawNum().keySet()) {
      // The second parameter asks the parser to parse the spectrum along
      // with meta-info about the scan itself
      IScan scan = source.parseScan(scanNumRaw, true);

      // Do something with the scan.
      // Note that some features, like scan.getChildScans() will not work in
      // this case, as there is not enough information to build those
      // relationships.

      System.out.println(scan.toString());
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how much faster the parsing has been and that only MS1 scans reported the number of points in the spectrum.&lt;/p&gt;

&lt;p&gt;It is a lot more effective to load data in chunks, rather than manually keeping track of what&amp;rsquo;s been loadad and what needs unloading, we will instead use the &lt;code&gt;ScanCollectionDefault&lt;/code&gt; data structure to that for us.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws FileParsingException {

  // Creating data source
  Path path = Paths.get(&amp;quot;some-path-to.mzXML&amp;quot;);
  path = Paths.get(args[0]);
  MZXMLFile source = new MZXMLFile(path.toString());

  // This is a data structure used to store scans and to navigate around the run
  ScanCollectionDefault scans = new ScanCollectionDefault();
  // Softly reference spectral data, make it reclaimable by GC
  scans.setDefaultStorageStrategy(StorageStrategy.SOFT);
  // Set it to automatically re-parse spectra from the file if spectra were not
  // yet parsed or were reclaimed to make auto-loading work you&#39;ll need to use
  // IScan#fetchSpectrum() method instead of IScan#getSpectrum()
  scans.isAutoloadSpectra(true);

  // Set our mzXML file as the data source for this scan collection
  scans.setDataSource(source);
  // Set number of threads for multi-threaded parsing.
  // null means use as many cores as reported by Runtime.getRuntime().availableProcessors()
  source.setNumThreadsForParsing(null);
  // load the meta-data about the whole run, with forced parsing of MS1 spectra
  // as we have enabled auto-loading, then if we ever invoke IScan#fetchSpectrum()
  // on an MS2 spectrum, for which the spectrum has not been parsed, it will be
  // obtained from disk automatically. And because of Soft referencing, the GC
  // will be able to reclaim it.
  scans.loadData(LCMSDataSubset.MS1_WITH_SPECTRA);

  // let&#39;s traverse the data-structure
  TreeMap&amp;lt;Integer, IScan&amp;gt; num2scanMap = scans.getMapNum2scan();
  for (IScan scan : num2scanMap.values()) {
    ISpectrum spectrum = scan.getSpectrum();
    if (spectrum == null) {
      System.out.printf(&amp;quot;%s does NOT have a parsed spectrum\n&amp;quot;, scan.toString());
    } else {
      System.out.printf(&amp;quot;%s has a parsed spectrum, it contains %d data points\n&amp;quot;,
                        scan.toString(), spectrum.getMZs().length);
    }
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a more complex example, loading spectra for custom ranges (scan number range and MS level combination) and adding better memory management for long-running applications.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws FileParsingException {
  // Creating data source
  Path path = Paths.get(&amp;quot;some-path-to.mzXML&amp;quot;);
  path = Paths.get(args[0]);
  MZXMLFile source = new MZXMLFile(path.toString());

  // Get the index (fetchXXX() methods will parse data from the file if it has not
  // yet been parsed) and cache it in the object for reuse.
  // You&#39;ll only need the index if you want to convert between internal scan numbers
  // and raw scan numbers in the file. Some files might have non-consecutive scan
  // numbers, for example, but internally they&#39;ll be renumbered to start from
  // 1 and increment by one for each next scan.
  MZXMLIndex idx = source.fetchIndex();
  // info about the run
  LCMSRunInfo runInfo = source.fetchRunInfo();


  // To parse a single scan from the file (or a range of scans) we first create a
  // predicate matching the scan to be parsed.
  // For example, parse scans from 1 to 3 at MS level 2.
  Set&amp;lt;Integer&amp;gt; msLevel = Collections.singleton(2);
  LCMSDataSubset subset = new LCMSDataSubset(1, 3, msLevel, null);
  List&amp;lt;IScan&amp;gt; parsedScans = source.parse(subset);

  // If you want higher level access to data, create an LCMSData object
  LCMSData data = new LCMSData(source);
  // load the whole structure of the run, and parse all spectra for MS1 scans
  data.load(LCMSDataSubset.WHOLE_RUN);
  data.releaseMemory();

  // or load the whole structure, but only get m/z-intensity info at MS level 2
  data.load(new LCMSDataSubset(null, null, msLevel, null));
  data.releaseMemory();
  // alternatively, use this shortcut
  data.load(LCMSDataSubset.MS2_WITH_SPECTRA);
  data.releaseMemory();

  // If you need memory management, you can also pass an instance of an object,
  // which will be considered the owner of prased data. When this object is
  // garbage collected, this will be detected automatically  and corresponding
  // spectra released.
  Object dataUser = new Object();
  data.load(LCMSDataSubset.WHOLE_RUN, dataUser);
  System.out.printf(&amp;quot;The data is loaded and used by [%s] object.\n&amp;quot;,
                    System.identityHashCode(dataUser));
  // at this point dataUser might be garbage collected as it&#39;s not referenced anymore,
  // and the data might get unloaded automatically
  dataUser = null; // just to be sure that we don&#39;t have a strong reference

  // If you don&#39;t want to fiddle around with memory management at all, but still
  // want it to play nicely there&#39;s one more feature - auto-loading of spectra.
  // You can parse the whole structure of the file and keep it in memory (it&#39;s
  // rather small), and just magically get the spectra whenever you need them.
  // Also set referenceing type to soft, so that garbage collector could reclaim
  // unused spectra.
  data.load(LCMSDataSubset.STRUCTURE_ONLY);

  IScanCollection scans = data.getScans();
  scans.isAutoloadSpectra(true); // set automatic spectra loading
  scans.setDefaultStorageStrategy(StorageStrategy.SOFT); // mz-intensity data will be softly referenced
  TreeMap&amp;lt;Integer, ScanIndex&amp;gt; msLevel2index = scans.getMapMsLevel2index();
  ScanIndex ms2idx = msLevel2index.get(2); // get the index at MS level 2

  // we&#39;ll iterate by scan numbers
  TreeMap&amp;lt;Integer, IScan&amp;gt; num2scan = ms2idx.getNum2scan();
  Set&amp;lt;Map.Entry&amp;lt;Integer, IScan&amp;gt;&amp;gt; scanEntries = num2scan.entrySet();
  for (Map.Entry&amp;lt;Integer, IScan&amp;gt; scanEntry : scanEntries) {
    Integer scanNum = scanEntry.getKey();
    IScan scan = scanEntry.getValue();

    // note that we use fetchXXX() method here, because we&#39;ve only parsed the structure
    // of the file, which includes scan meta-data, but not the spectra themselves
    ISpectrum spectrum = scan.fetchSpectrum();
    int scanNumInternal = scan.getNum(); // internal scan number (1 based)
    IndexElement idxElem = idx.getByNum(scanNumInternal);
    int scanNumRaw = idxElem.getRawNumber();
    int numPoints = spectrum.getMZs().length;
    System.out.printf(&amp;quot;Scan #%d (raw #%d) contained %d data points\n&amp;quot;,
                      scanNumInternal, scanNumRaw, numPoints);
  }

  // You can use the ScanCollection API to navigate around the LCMS run.
  // E.g., get the number fo the first scan at ms lelvel 2
  Integer firstMS2ScanNum = scans.getMapMsLevel2index().get(2).getNum2scan().firstKey();
  IScan scan = scans.getScanByNum(firstMS2ScanNum);
  // Now get the next scan at the same MS level
  scan = scans.getNextScanAtSameMsLevel(scan);

  // Because we did parsing of the whole structure, an important method was called
  // automagically for us: ScanCollectionHelper.finalizeScanCollection(scans),
  // which sets up parent child relations between scans even if that information was
  //  not in the scan meta-data. You can also call this method yourself if it you
  // only parse a portion of the file
  String parentScanRef = scan.getPrecursor().getParentScanRefRaw();
  System.out.printf(&amp;quot;Scan #%d (MS%d) is a child scan of {%s}\n&amp;quot;,
                    scan.getNum(), scan.getMsLevel(), parentScanRef);

  data.releaseMemory();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope the comments in the code are enough to get you started.&lt;/p&gt;

&lt;h2 id=&#34;parsing-identification-files-pepxml-protxml-mzidentml&#34;&gt;Parsing identification files (PepXML, ProtXML, MzIdentML)&lt;/h2&gt;

&lt;p&gt;The library gives low level access to those file formats. There is no unifying API here, as the formats are very different. These parsers are not hand optimized for efficiency, so they might consume quite a bit more memory than they should, but they also are error resilient.&lt;/p&gt;

&lt;p&gt;Working with these files is simpler, you call the parser and get a single data-structure, that follows the schemas of corresponding XMLs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
Path path = Paths.get(&amp;quot;some-path-to.pep.xml&amp;quot;);

// a single call to parse the whole file
MsmsPipelineAnalysis msmsPipelineAnalysis = PepXmlParser.parse(path);


List&amp;lt;MsmsRunSummary&amp;gt; msmsRunSummaries = msmsPipelineAnalysis.getMsmsRunSummary();
for (MsmsRunSummary msmsRunSummary : msmsRunSummaries) {
    List&amp;lt;SpectrumQuery&amp;gt; spectrumQueries = msmsRunSummary.getSpectrumQuery();
    System.out.printf(&amp;quot;Spectrum queries from MS/MS run summary: %s\n&amp;quot;,
                      msmsRunSummary.getBaseName());
    for (SpectrumQuery sq : spectrumQueries) {
        System.out.printf(&amp;quot;Spec ID: [%s], RT: [%.2f], precursor neutral mass: [%.3f]\n&amp;quot;,
                          sq.getSpectrum(), sq.getRetentionTimeSec(), sq.getPrecursorNeutralMass());
    }
    System.out.printf(&amp;quot;Done with MS/MS run summary: %s\n&amp;quot;, msmsRunSummary.getBaseName());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parsing-huge-identification-files-more-efficiently&#34;&gt;Parsing huge identification files more efficiently&lt;/h2&gt;

&lt;p&gt;Sometimes you might have PepXML files that are many gigabytes in size, this happens when you combine search results from multiple experiments and store them in a single output file. In that case, using &lt;code&gt;XMLStreamReader&lt;/code&gt; class it is possible to first rewind the input stream to some large structural element of the underlying file, such as &lt;code&gt;&amp;lt;msms_run_summary&amp;gt;&lt;/code&gt; in PepXML files.&lt;br /&gt;
You will need to have an idea of how the files are organized for this to work in general though, explore the corresponding XML schemas. The schemas can also be found in the sources of the library in file-specific sub-packages of &lt;code&gt;umich.ms.fileio.filetypes&lt;/code&gt; in &lt;code&gt;resources&lt;/code&gt; directories.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {
  // we&#39;ll manually iterate over msmsRunSummaries - won&#39;t need so much memory
  // at once for processing large files.
  JAXBContext ctx = JAXBContext.newInstance(MsmsRunSummary.class);
  Unmarshaller unmarshaller = ctx.createUnmarshaller();

  XMLInputFactory xif = XMLInputFactory.newFactory();
  StreamSource ss = new StreamSource(is);
  XMLStreamReader xsr = xif.createXMLStreamReader(ss);


  while (advanceReaderToNextRunSummary(xsr)) {
    // we&#39;ve advanced to the next MsmsRunSummary in the file
    long timeLo = System.nanoTime();
    JAXBElement&amp;lt;MsmsRunSummary&amp;gt; unmarshalled = unmarshaller
                                          .unmarshal(xsr, MsmsRunSummary.class);
    long timeHi = System.nanoTime();
    System.out.printf(&amp;quot;Unmarshalling took %.4fms (%.2fs)\n&amp;quot;,
                      (timeHi-timeLo)/1e6, (timeHi-timeLo)/1e9);
    MsmsRunSummary runSummary = unmarshalled.getValue();
    if (runSummary.getSpectrumQuery().isEmpty()) {
      String msg = String.format(&amp;quot;Parsed msms_run_summary was empty for file &amp;quot; +
          &amp;quot;&#39;%s&#39;, summary base_name &#39;%&#39;&amp;quot;, uri.toString(), runSummary.getBaseName());
      System.out.println(msg);
    }
  }
} catch (JAXBException | XMLStreamException e) {
  // do something with the exception
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and here is the meat of it, the code to rewind the &lt;code&gt;XMLStreamReader&lt;/code&gt; - &lt;code&gt;advanceReaderToNextRunSummary(XMLStreamReader)&lt;/code&gt;.
In this case the example assumes we try to parse multiple msms_run_summary tags one by one from the file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
private static final String TAG_RUN_SUMMARY = &amp;quot;msms_run_summary&amp;quot;;

private static boolean advanceReaderToNextRunSummary(XMLStreamReader xsr)
    throws XMLStreamException {
  long timeLo = System.nanoTime();
  do {
      if (xsr.next() == XMLStreamConstants.END_DOCUMENT)
          return false;
  } while (!(xsr.isStartElement() &amp;amp;&amp;amp; xsr.getLocalName().equals(TAG_RUN_SUMMARY)));

  long timeHi = System.nanoTime();
  System.out.printf(&amp;quot;Advancing reader took: %.4fms\n&amp;quot;, (timeHi-timeLo)/1e6d);

  return true;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Setting up development environment</title>
      <link>http://www.batmass.org/tutorial/setting-up-development-environment/</link>
      <pubDate>Thu, 14 Apr 2016 00:31:00 -0400</pubDate>
      
      <guid>http://www.batmass.org/tutorial/setting-up-development-environment/</guid>
      <description>

&lt;p&gt;This guide will quickly step you through setting up the environment for developing new functionality for BatMass. All the downloads, setting up the IDE and up to building BatMass from scratch.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-development-environement-for-batmass&#34;&gt;Setting up development environement for BatMass&lt;/h2&gt;

&lt;p&gt;You will only need this information if you want to develop your own plugins
for BatMass or change its functionality in some way, if you&amp;rsquo;re just a regular
user you can skip this tutorial.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t be scared by the size of this tutorial, it just assumes that you know
nothing about NetBeans and the NetBeans Platform. All the steps are simple.&lt;/p&gt;

&lt;h2 id=&#34;get-the-jdk-java-development-kit&#34;&gt;Get the JDK (Java Development Kit)&lt;/h2&gt;

&lt;p&gt;BatMass is written in Java, so we&amp;rsquo;ll need Java. Download and isntall JDK 7:
&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html&#34;&gt;e.g. from Oracle&lt;/a&gt;.
It should work with &lt;em&gt;OpenJDK&lt;/em&gt; as well.&lt;/p&gt;

&lt;h2 id=&#34;the-netbeans-platform&#34;&gt;The NetBeans platform&lt;/h2&gt;

&lt;p&gt;BatMass is built on top of the NetBeans platform (we will call it just &lt;strong&gt;the
platform&lt;/strong&gt; or &lt;strong&gt;NBP&lt;/strong&gt; for simplicity). It&amp;rsquo;s the same infrastructure  that the NetBeans IDE
is built on top of itself. This is an essential part of the setup, it is the
platform that provides the Window system, the Loader, Automatic Updates and much more.
All platform applications are developed against some version of the platform,
which itself is just a collection of libraries (called &lt;em&gt;Modules&lt;/em&gt;). Though it is
possible to use the platform that comes with the NetBeans IDE, you&amp;rsquo;ll likely
encounter multiple errors due to incorrect dependency versions, so &lt;strong&gt;you&amp;rsquo;ll need
to get the platform version that we are providing&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Developing platform applications is much simpler with the NetBeans IDE as it
provides a lot of wizards and other core functionality. It is possible to use
&lt;em&gt;ItelliJ&lt;/em&gt; as well, but we will not be covering this option, so &lt;a href=&#34;https://netbeans.org/downloads/&#34;&gt;go ahead and get
the latest version of NetBeans&lt;/a&gt; (which is 8.1
as of this writing). You can select the &lt;em&gt;Java SE&lt;/em&gt; version among all downloads.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download the platform files: &lt;a href=&#34;https://github.com/chhh/batmass/releases/download/v.0.1.0/nb81-batmass.zip&#34;&gt;from BatMass github repository&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Unpack the downloaded archive, it contains four zip files&lt;/li&gt;
&lt;li&gt;Unpack the following 3 files to the same location, e.g. &lt;code&gt;/&amp;lt;path&amp;gt;/nbp&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;netbeans-...-harness.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;netbeans-...-ide.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;netbeans-...-platform.zip&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Do not unpack &lt;code&gt;netbeans-8.1-...-platform-src.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You should now have &lt;code&gt;/&amp;lt;path&amp;gt;/nbp/harness&lt;/code&gt;, &lt;code&gt;/&amp;lt;path&amp;gt;/nbp/ide&lt;/code&gt;,
&lt;code&gt;/&amp;lt;path&amp;gt;/nbp/platform&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start the NetBeans IDE.&lt;/li&gt;
&lt;li&gt;In the main menu: &lt;em&gt;Tools -&amp;gt; NetBeans Platforms&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Click &lt;em&gt;Add Platform&lt;/em&gt; and select &lt;code&gt;/&amp;lt;path&amp;gt;/nbp&lt;/code&gt;, the &lt;em&gt;Platform Name&lt;/em&gt; text box
on the right will show something like &lt;em&gt;nb81&lt;/em&gt;, which means that the directory
has been recognized as containing &lt;em&gt;platform&lt;/em&gt; files.&lt;/li&gt;
&lt;li&gt;Click &lt;em&gt;Next&lt;/em&gt;, change the platform name to &lt;code&gt;nb-batmass&lt;/code&gt; (&lt;strong&gt;This is very
important!&lt;/strong&gt;) as it is and click &lt;em&gt;Finish&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;You should now see the newly created &lt;em&gt;platform&lt;/em&gt; in the list, like this:&lt;br /&gt;
&lt;img src=&#34;http://www.batmass.org/images/setting-up-development-environment/nb-platform-created.png&#34; alt=&#34;NetBeans platform added&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Change the tab to &lt;em&gt;Harness&lt;/em&gt; and make sure to switch the radio button to
&lt;em&gt;Harness supplied with Platform&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Change the tab to &lt;em&gt;Sources&lt;/em&gt; and add the path to &lt;em&gt;.zip&lt;/em&gt; file
&lt;code&gt;netbeans-*-platform-src.zip&lt;/code&gt; that came with your platform download.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You should now have the environment set-up to bebing development.&lt;/p&gt;

&lt;h2 id=&#34;batmass-modules&#34;&gt;BatMass modules&lt;/h2&gt;

&lt;p&gt;BatMass itself is composed of multiple modules which are split into several
module suits. A module suite in the platform terms is just a collection of
modules groupped together all of which have access to some common set of
dependencies. Each suite lives in its own github repository, clone them all to
the to the same location:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/batmass&#34;&gt;BatMass&lt;/a&gt; - the main suite, most of
development happens here&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/batmass-libs&#34;&gt;BatMassLibs&lt;/a&gt; - all the library
dependencies reside in this suite. In&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/batmass-ext&#34;&gt;BatMassExternalSuite&lt;/a&gt; - contains
separate functional pieces borrowed from the web or elsewhere. E.g. the color-
picker used in the options lives here.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/MSFTBX&#34;&gt;MSFTBX&lt;/a&gt; - this is the data access library.
It provides pure-java implementations of &lt;em&gt;mzXML&lt;/em&gt;, &lt;em&gt;mzML&lt;/em&gt;, &lt;em&gt;pep.xml&lt;/em&gt;, &lt;em&gt;prot.xml&lt;/em&gt;
files among some others as well. The API (interfaces) is bundled with it.&lt;br /&gt;
Although this repository contains a NetBeans platform module project, you&amp;rsquo;ll
also notice that it contains a regular IntelliJ IDEA project as well, which
has artifacts configured to build a regular &lt;em&gt;jar&lt;/em&gt; out of it.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir /&amp;lt;some-path&amp;gt;/batmass-projects
cd /&amp;lt;some-path&amp;gt;/batmass-projects
git clone https://github.com/chhh/batmass.git
git clone https://github.com/chhh/batmass-libs.git
git clone https://github.com/chhh/batmass-ext.git
git clone https://github.com/chhh/MSFTBX.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You now have all the source code and libraries necessary to build BatMass.&lt;/p&gt;

&lt;h2 id=&#34;building-the-projects&#34;&gt;Building the projects&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Start NetBeans IDE&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Main Menu -&amp;gt; File -&amp;gt; Open Project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Holding down &lt;kbd&gt;Ctrl&lt;/kbd&gt; select the 4 cloned projects, and open them (see
image below)
&lt;img src=&#34;http://www.batmass.org/images/setting-up-development-environment/netbeans-opening-projects.png&#34; alt=&#34;Open Cloned Projects&#34; /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Check the bottom right corner of the IDE for a progress bar, it might take a
while to index the projects.&lt;/li&gt;
&lt;li&gt;Right click &lt;code&gt;BatMass&lt;/code&gt; project, select &lt;code&gt;Properties&lt;/code&gt; in the context menu.&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Libraries&lt;/code&gt; in the &lt;em&gt;Categories&lt;/em&gt; list on the left.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Make sure that drop-down &lt;em&gt;NetBeans Platform&lt;/em&gt; is set to &lt;code&gt;nb-batmass&lt;/code&gt; as in
the image below, if this shows some other platform, switch to &lt;code&gt;nb-batmass&lt;/code&gt;&lt;br /&gt;
&lt;img src=&#34;http://www.batmass.org/images/setting-up-development-environment/netbeans-project-batmass-check-library-settings.png&#34; alt=&#34;Make sure opened projects are set to use the provided platform&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If you see some errors in the &lt;em&gt;Project Properties&lt;/em&gt; window (e.g. saying that
some module lacks some dependencies, and the &lt;em&gt;Resolve&lt;/em&gt; button is inactive),
please contact us.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check the selected platform for the other 3 projects as well.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;we-are-ready-to-build-the-final-product&#34;&gt;We are ready to build the final product!&lt;/h2&gt;

&lt;p&gt;The build order is of importance. Automatic rebuilding of dependent module suits
was not set up to improve build performance.&lt;br /&gt;
Only the &lt;code&gt;BatMass&lt;/code&gt; project depends on others, so whenever you make changes to
&lt;code&gt;BatMassLibs&lt;/code&gt;, &lt;code&gt;BatMassExternalSuite&lt;/code&gt; or &lt;code&gt;MSFTBX&lt;/code&gt; you will need to manually
trigger a &lt;code&gt;clean build&lt;/code&gt; on them, and rebuild the &lt;code&gt;BatMass&lt;/code&gt; project  after that.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Right click &lt;code&gt;MSFTBX&lt;/code&gt; project node in the &lt;em&gt;Project Explorer&lt;/em&gt; and choose &lt;code&gt;clean
build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Now do &lt;code&gt;clean build&lt;/code&gt; for &lt;code&gt;BatMassLibs&lt;/code&gt; and &lt;code&gt;BatMassExternalSuite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can now &lt;code&gt;clean build&lt;/code&gt; the main &lt;code&gt;BatMass&lt;/code&gt; project&lt;/li&gt;
&lt;li&gt;When the build is done, go to &lt;code&gt;Main menu -&amp;gt; Run -&amp;gt; Set main project&lt;/code&gt; and
select &lt;code&gt;BatMass&lt;/code&gt; there. This will force the green &lt;code&gt;Run&lt;/code&gt; button (&lt;kbd&gt;F6&lt;/kbd&gt;
shortcurt) to always launch this project and not the currently selected one.&lt;/li&gt;
&lt;li&gt;Run the project: &lt;code&gt;Main menu -&amp;gt; Run -&amp;gt; Run main project&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If all is well and you can start the project, you should also be able to
create the installers for it. Right click &lt;code&gt;BatMass&lt;/code&gt; project, &lt;code&gt;Package as -&amp;gt;
Installers&lt;/code&gt;. This is a time-consuming process, when done, you&amp;rsquo;ll find the
installers for different platforms in &lt;code&gt;batmass-projects/batmass/dist&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Contact information</title>
      <link>http://www.batmass.org/contacts/</link>
      <pubDate>Thu, 14 Apr 2016 00:20:00 -0400</pubDate>
      
      <guid>http://www.batmass.org/contacts/</guid>
      <description>

&lt;p&gt;Please use the &lt;a href=&#34;https://github.com/chhh/batmass/issues&#34;&gt;bug tracker&lt;/a&gt; to request additional functionality or report bugs.&lt;/p&gt;

&lt;h2 id=&#34;referencing-the-work&#34;&gt;Referencing the work&lt;/h2&gt;

&lt;p&gt;The paper is due to be published.&lt;/p&gt;

&lt;h2 id=&#34;the-author-and-maintainer-of-the-project&#34;&gt;The author and maintainer of the project&lt;/h2&gt;

&lt;p&gt;Dmitry Avtonomov, Ph.D. (University of Michigan, Ann Arbor)&lt;br /&gt;
Email: dmitriya@umich.edu&lt;/p&gt;

&lt;h2 id=&#34;general-inquiries&#34;&gt;General inquiries&lt;/h2&gt;

&lt;p&gt;Alexey Nesvizhskii, Ph.D. (University of Michigan, Ann Arbor)&lt;br /&gt;
Email: nesvi@umich.edu&lt;br /&gt;
&lt;a href=&#34;http://www.nesvilab.org&#34;&gt;http://www.nesvilab.org&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MSFTBX: Mass-Spec File Toolbox, the data access library</title>
      <link>http://www.batmass.org/data-access-lib/</link>
      <pubDate>Thu, 14 Apr 2016 00:15:01 -0400</pubDate>
      
      <guid>http://www.batmass.org/data-access-lib/</guid>
      <description>

&lt;p&gt;The data access library is at the core of &lt;em&gt;BatMass&lt;/em&gt;, but is a separate standalone project. It can be used in regular Java programs (read as a &lt;em&gt;jar&lt;/em&gt; library) and NetBeans platform applications via the included NetBeans Module wrapper.&lt;/p&gt;

&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Single API to &lt;strong&gt;mzML&lt;/strong&gt; and &lt;strong&gt;mzXML&lt;/strong&gt; files&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mzML&lt;/strong&gt; and &lt;strong&gt;mzXML&lt;/strong&gt; parsing

&lt;ul&gt;
&lt;li&gt;Very fast multi-threaded parser&lt;/li&gt;
&lt;li&gt;Can separately parse LC/MS run information, the index and data&lt;/li&gt;
&lt;li&gt;Separation of parsing of scan meta-information and spectral data&lt;/li&gt;
&lt;li&gt;Automatic indexing of the data

&lt;ul&gt;
&lt;li&gt;maps from scan numbers to scans&lt;/li&gt;
&lt;li&gt;maps from retention time to scans&lt;/li&gt;
&lt;li&gt;same maps separately at each MS level&lt;/li&gt;
&lt;li&gt;automatic DIA (data Independent Acquisition) detection and automated grouping of DIA MS2 scans according to the corresponding isolation windows&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Memory management

&lt;ul&gt;
&lt;li&gt;can parse the whole structure of the run (all scans with all meta-info) and dynamically parse spectral data from the disk only when it&amp;rsquo;s accessed&lt;/li&gt;
&lt;li&gt;an object can be used as the &amp;lsquo;owner&amp;rsquo; of loaded data, if the &amp;lsquo;owner&amp;rsquo; is garbage collected, and no other &amp;lsquo;owners&amp;rsquo; claimed the scans, the corresponding resources can be automatically released&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tolerance to broken index

&lt;ul&gt;
&lt;li&gt;automatically detects errors in the index, such as all scan offsets are the same (which happens with some versions of ProteoWizard&amp;rsquo;s &lt;em&gt;msconvert&lt;/em&gt; when converting large files)&lt;/li&gt;
&lt;li&gt;if the index is not present, will reindex the file&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tolerance to MS2 scan tags being enclosed in the corresponding MS1 scan tag (old data converted with ReAdW)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PepXML&lt;/strong&gt; parsing/writing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ProtXML&lt;/strong&gt; parsing/writing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MzIdentML&lt;/strong&gt; parsing/writing&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;Take a look at &lt;a href=&#34;http://www.batmass.org/tutorial/data-access-layer/&#34;&gt;this tutorial&lt;/a&gt; for a short introduction and check the &lt;a href=&#34;https://github.com/chhh/msftbx&#34;&gt;sources at github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting started</title>
      <link>http://www.batmass.org/getting-started/</link>
      <pubDate>Thu, 14 Apr 2016 00:10:00 -0400</pubDate>
      
      <guid>http://www.batmass.org/getting-started/</guid>
      <description>

&lt;p&gt;This guide will quickly step you through the installation, creation of a project and viewing mzML/mzXML files.&lt;/p&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;Download the latest release for your platform from &lt;a href=&#34;https://github.com/chhh/batmass/releases/latest&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/batmass/releases/download/v.0.04/batmass-windows.exe&#34;&gt;Windows installer&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is preferable to install BatMass to non-system locations (e.g. not into &lt;em&gt;Program Files&lt;/em&gt; or similar locations) as you might need Administrator privileges to modify the configuration file.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/batmass/releases/download/v.0.04/batmass-linux.sh&#34;&gt;Linux installer&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/batmass/releases/download/v.0.04/batmass-macosx.tgz&#34;&gt;MacOS installer&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/chhh/batmass/releases/download/v.0.04/batmass.zip&#34;&gt;Platform independent zip&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;If you select the platform independent version, you&amp;rsquo;ll have to launch &lt;em&gt;BatMass&lt;/em&gt; by manually running the correct executable for your platform from &lt;em&gt;&amp;lt;extracted-archive-path&amp;gt;/bin/&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;You can skip this section if you can launch the application and view the files without problems.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The only two things you might want to configure are the maximum amount of memory, that &lt;em&gt;BatMass&lt;/em&gt; will be allowed to use and the path to JRE (Java Runtime Environment). The default amount of RAM is set to 4GB, if your machine doesn&amp;rsquo;t have that much, the JVM won&amp;rsquo;t start.&lt;br /&gt;
The startup configuration is stored in &lt;code&gt;&amp;lt;batmass-install-path&amp;gt;/etc/batmass.conf&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Max memory is set up in &lt;code&gt;default_options&lt;/code&gt; option, the flag is &lt;code&gt;-J-Xmx&lt;/code&gt;. By default after installation you&amp;rsquo;ll find that it is set to &lt;code&gt;-J-Xmx4G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can set any standard JVM startup options using this &lt;code&gt;default_options&lt;/code&gt; line, just prepend the arguments with &lt;code&gt;-J-&lt;/code&gt;. E.g. &lt;code&gt;-J-DisableExplicitGC&lt;/code&gt;, however you likely won&amp;rsquo;t need that.&lt;/li&gt;
&lt;li&gt;If you get a message that the JRE can&amp;rsquo;t be found, try explicitly specifying the full path using the &lt;code&gt;jdkhome&lt;/code&gt; option of &lt;code&gt;batmass.conf&lt;/code&gt;. Even though the name says &lt;code&gt;jdk&lt;/code&gt;, it&amp;rsquo;s actually the path to the JRE. The line with that option is commented out by default, so remove the &lt;code&gt;#&lt;/code&gt; symbol at the beginning of the line and set the path, e.g. &lt;code&gt;jdkhome=&amp;quot;C:\Program Files\Java\jre1.8.0_77&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note to Windows users&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;ve isntalled BatMass into some system folder (most commonly &lt;em&gt;C:\Program Files\batmass&lt;/em&gt;), you might need to run text editor as Administrator in order to edit the config file, otherwise you likely won&amp;rsquo;t be able to save changes to &lt;em&gt;batmass.conf&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;creating-a-project&#34;&gt;Creating a project&lt;/h2&gt;

&lt;p&gt;Go to &lt;code&gt;Main menu -&amp;gt; New project&lt;/code&gt;, select any project type when presented with a choice, it won&amp;rsquo;t matter now. Choose an existing directory or create a new empty one for the project, all the project-related files will be created inside this directory and &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;a new directory with the project name under the selected directory&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The project should now appear in the &lt;em&gt;Project Explorer&lt;/em&gt; tab on the left. Expand the project&amp;rsquo;s node and right click &lt;code&gt;LC/MS Files&lt;/code&gt; node, choose &lt;code&gt;Import LC/MS Files&lt;/code&gt;. You can select multiple files at once by holding &lt;kbd&gt;Shift&lt;/kbd&gt; or &lt;kbd&gt;Ctrl&lt;/kbd&gt;, you can also restrict the files that are being shown to a particular format using the drop-down menu on the bottom of the file-chooser.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Memory usage&lt;/p&gt;
&lt;p&gt;For opening large LC/MS runs in Map 2D viewer BatMass requires enough memory to load the whole MS level in memory (MS&lt;sup&gt;1&lt;/sup&gt; or MS&lt;sup&gt;2&lt;/sup&gt; or a single &amp;lsquo;swath&amp;rsquo;/&amp;lsquo;window&amp;rsquo; of MS&lt;sup&gt;2&lt;/sup&gt; in case of DIA), the default configuration file is set to use 4GB of RAM maximum. This has two implications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If your machine does not have enough available RAM you might not be able to run the program at all. E.g. MS&lt;sup&gt;1&lt;/sup&gt; only run of 10GB on a machine with 4GB RAM (You should still be able to view spectra though).&lt;/li&gt;
&lt;li&gt;To open larger experiments (multi-gigabyte mzML/mzXML files) you might want to set larger memory limit in the configuration file discussed above.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;viewer-controls&#34;&gt;Viewer controls&lt;/h2&gt;

&lt;p&gt;Open one of the files in the 2D viewer by right clicking and &lt;code&gt;View -&amp;gt; 2D Map&lt;/code&gt; as shown below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/getting-started/view-file.png&#34; alt=&#34;Open a file as a 2D Map&#34; /&gt;&lt;/p&gt;

&lt;p&gt;File parsing might take some time, when it&amp;rsquo;s done you should see something akin to the following.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.batmass.org/images/getting-started/standard-lcms-run-map2d.png&#34; alt=&#34;Map 2D viewer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The image can be zoomed and panned using the mouse and keyboard.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Drag to zoom&lt;/strong&gt;. Press the left mouse button (&lt;code&gt;LMB&lt;/code&gt;) and drag.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zoom in/out with mouse wheel&lt;/strong&gt;. Using the mouse wheel with &lt;kbd&gt;Shift&lt;/kbd&gt; or &lt;kbd&gt;Alt&lt;/kbd&gt; modifiers will restrict zooming to only m/z or RT direction (the mnemonic rule is that the &lt;kbd&gt;Shift&lt;/kbd&gt; key is streched out horizontally, so it corresponds to m/z direction, which is horizontal in charts).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go To Dialog&lt;/strong&gt;. If you are interested in a particular location, you can use this dialog to type in the coordinates. While a chart has focus, press &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;G&lt;/kbd&gt; or click the magnifying glass icon &lt;img src=&#34;http://www.batmass.org/images/getting-started/icon_zoom.png&#34; alt=&#34;Link icon&#34; /&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Panning&lt;/strong&gt;. Hold &lt;kbd&gt;Ctrl&lt;/kbd&gt; while dragging the mouse to pan the view.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Restricted panning&lt;/strong&gt;. Using the same modifier keys (&lt;kbd&gt;Shift&lt;/kbd&gt; or &lt;kbd&gt;Alt&lt;/kbd&gt;) panning can be restricted to only one direction.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zoom out to original full overview&lt;/strong&gt;. &lt;kbd&gt;Ctrl+Alt+Shift&lt;/kbd&gt;+&lt;code&gt;LMB click&lt;/code&gt; will un-zoom the image completely, bringing you to the view of the whole experiment.&lt;/li&gt;
&lt;li&gt;If you accidentally zoom to wrong location use the &lt;code&gt;Undo&lt;/code&gt; button in the main toolbar.&lt;/li&gt;
&lt;li&gt;If you are viewing DIA (Data Independent Acquisition) data, the toolbar of the 2D viewer should have drop-down menus for MS level and precursor windows in case of MS&lt;sup&gt;2&lt;/sup&gt;. After you change the MS level or precursor window in the drop-down, you&amp;rsquo;ll need to click the Refresh icon &lt;img src=&#34;http://www.batmass.org/images/getting-started/icon_update.png&#34; alt=&#34;Refresh icon&#34; /&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;linking-viewers&#34;&gt;Linking viewers&lt;/h2&gt;

&lt;p&gt;Multiple viewers can be linked together by dragging and dropping the link icon &lt;img src=&#34;http://www.batmass.org/images/getting-started/icon_link.png&#34; alt=&#34;Link icon&#34; /&gt; from the viewer toolbar to another viewer&amp;rsquo;s link icon. You can do this for multiple viewers of different types to assemble thme into groups. Clicking on the link icon will highlight the other viewer windows which are currently in in the same linked group, i.e. all synchronized, their borders will be highlighted by the same color. By clicking the unlink button in the viewer&amp;rsquo;s toolbar &lt;img src=&#34;http://www.batmass.org/images/getting-started/icon_unlink.png&#34; alt=&#34;Link icon&#34; /&gt;, you can remove viewers from the group.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BatMass: mass spectrometry data visualization</title>
      <link>http://www.batmass.org/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:01 -0400</pubDate>
      
      <guid>http://www.batmass.org/</guid>
      <description>

&lt;h2 id=&#34;about-batmass&#34;&gt;About BatMass&lt;/h2&gt;

&lt;p&gt;BatMass is a mass-spectrometry data visualization tool, with the main focus on being fast and interactive while providing comprehensive visualizations without any parameter tweaking. It is written in pure Java and built on top of the &lt;a href=&#34;https://netbeans.org/features/platform/all-docs.html&#34;&gt;NetBeans Platform&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Support for the open standard &lt;em&gt;mzML&lt;/em&gt; and &lt;em&gt;mzXML&lt;/em&gt; mass spectrometry data types. We are hoping to bring native vendor format support as well.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Viewer synchronization. Link any number of viewers and zooming/panning will be synchronized across them. If you&amp;rsquo;re viewing MS&lt;sup&gt;1&lt;/sup&gt; data in one view and MS&lt;sup&gt;2&lt;/sup&gt; data in the other the retention time is synchronized, while m/z is not. Open a detected LC/MS feature table or a peptide identification table, a double click on the row will open the corresponding spectrum, or bring you to the corresponding location in a 2D Map viewer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Data access layer. For the Java developers out there, the highly optimized mzML/mzXML parsers can be used in any standalone Java program as a simple &lt;em&gt;jar&lt;/em&gt; dependency. Parsing has been manually tuned to produce few garbage objects, thus minimizing time spent in GC (Garbage Collection), the speed is comparable to or better than in C/C++ implementations. The API for LC/MS data files gives access to most of the features supported by mzML/mzXML standards.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See the &lt;a href=&#34;http://www.batmass.org/getting-started/&#34;&gt;getting started guide&lt;/a&gt; for instructions how to get
it up and running.&lt;/p&gt;

&lt;h2 id=&#34;demo-video&#34;&gt;Demo Video&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s a short demo video of BatMass in action.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/EY9wvd6ckb0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;some-examples&#34;&gt;Some Examples&lt;/h2&gt;

&lt;p&gt;The layout of windows is free and customizable by dragging.
&lt;img src=&#34;http://www.batmass.org/images/about-batmass/free-layout.png&#34; alt=&#34;Free window layoyt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Compare multiple experiments at once. The bottom-middle run in this figure is a blank (no sample was injected), while the other 5 were runs with some sample. Amazing how much stuff comes from the background.
&lt;img src=&#34;http://www.batmass.org/images/about-batmass/comparison-6-runs-1-blank.png&#34; alt=&#34;Multi experiment comparison in Map2D&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And here are the same runs but zoomed in to a small region of m/z and retentino time. Look at the color-marked regions. Let&amp;rsquo;s just accept that zero-values are a thing, there is no need to try extracting noise to do gap-filling in data.
&lt;img src=&#34;http://www.batmass.org/images/about-batmass/comparison-6-runs-1-blank-02-zoom-marked.png&#34; alt=&#34;Multi experiment comparison in Map2D zoomed&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;contacts&#34;&gt;Contacts&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;The author and maintainer of the project&lt;/strong&gt;&lt;br /&gt;
Dmitry Avtonomov, Ph.D.&lt;br /&gt;
University of Michigan, Ann Arbor&lt;br /&gt;
Email: dmitriya@umich.edu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;General inquiries&lt;/strong&gt;&lt;br /&gt;
Alexey Nesvizhskii, Ph.D.&lt;br /&gt;
University of Michigan, Ann Arbor&lt;br /&gt;
Email: nesvi@umich.edu&lt;br /&gt;
&lt;a href=&#34;http://www.nesvilab.org&#34;&gt;http://www.nesvilab.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Please use the &lt;a href=&#34;https://github.com/chhh/batmass/issues&#34;&gt;bug tracker&lt;/a&gt; to ask questions, submit feature requests and bug reports.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>